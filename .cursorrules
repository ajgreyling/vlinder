# Vlinder Dart Code Rules

## Hetu Script API Usage (0.4.2+1)

### Initialization
- **ALWAYS** call `hetu.init()` after creating a `Hetu()` instance and before using any other methods
- Example:
```dart
final hetu = Hetu();
hetu.init(); // REQUIRED - must be called first
```

### Variable Access
- Use `hetu.fetch(String varName)` to get variables - **NOT** `getType()`
- Returns `dynamic` - can be `HTStruct`, `HTFunction`, or Dart primitive types
- Example:
```dart
final value = hetu.fetch('variableName');
if (value is HTStruct) {
  // Access struct members
}
```

### Function Invocation
- Use `hetu.invoke(String funcName, {List<dynamic> positionalArgs, Map<String, dynamic> namedArgs})` - **NOT** `call()`
- Example:
```dart
final result = hetu.invoke('functionName', positionalArgs: [1, 2, 3]);
```

### Type Checking
- **DO NOT** use `HTString`, `HTInt`, `HTFloat`, `HTBool`, `HTNull`, `HTList` - these types don't exist
- Use Dart native types: `String`, `int`, `double`, `bool`, `null`, `List`
- Example:
```dart
// CORRECT
if (value is String) { ... }
if (value is int) { ... }
if (value == null) { ... }
if (value is List) { ... }

// INCORRECT - these types don't exist
if (value is HTString) { ... }  // WRONG
if (value is HTInt) { ... }      // WRONG
```

### HTStruct Usage
- Import `package:hetu_script/values.dart` when using `HTStruct`
- Access values using `struct[key]` or iterate with `for (final key in struct.keys)`
- Values stored in HTStruct are Dart native types
- **CRITICAL**: HTStruct uses **string keys** for member access
  - When storing data in HTStruct, convert numeric keys to strings: `"${key}"`
  - When accessing data, use string keys: `struct["1"]` not `struct[1]`
- Example:
```dart
import 'package:hetu_script/values.dart';

if (value is HTStruct) {
  // Iterate over keys
  for (final key in value.keys) {
    final val = value[key]; // Returns Dart native type
  }
  
  // Direct access (use string keys)
  final name = value['name']; // String (Dart type)
  final age = value['age'];   // int (Dart type)
  final result = value['1'];  // Access with string key
}
```

### Converting HTStruct to Dart Types
- **CRITICAL**: Always convert HTStruct to Dart types before passing to Dart APIs
- Use `_convertHetuValueToDart()` helper function that handles HTStruct:
```dart
dynamic _convertHetuValueToDart(dynamic value) {
  if (value is String || value is int || value is double || value is bool || value == null) {
    return value;
  } else if (value is List) {
    return value.map((e) => _convertHetuValueToDart(e)).toList();
  } else if (value is HTStruct) {
    // Convert HTStruct to Map<String, dynamic>
    final result = <String, dynamic>{};
    for (final key in value.keys) {
      result[key.toString()] = _convertHetuValueToDart(value[key]);
    }
    return result;
  } else if (value is Map) {
    final result = <String, dynamic>{};
    for (final entry in value.entries) {
      final key = entry.key.toString();
      result[key] = _convertHetuValueToDart(entry.value);
    }
    return result;
  }
  return value.toString();
}
```

### Script Evaluation
- Use `hetu.eval(String script)` to evaluate Hetu script strings
- Returns the result of the last expression
- Example:
```dart
final result = hetu.eval('final x = 42; x * 2'); // Returns 84
```

### Hetu Script Syntax Requirements
- **CRITICAL**: Widget constructor functions MUST use **named parameters** `{param1, param2}` to match UI script calls
- UI scripts call widgets with named parameter syntax: `Screen(id: 'x', title: 'y', children: [...])`
- Constructor functions must be defined with named parameters: `fun Screen({id, title, children})`
- If constructors use positional parameters, Hetu won't match named arguments and properties will be null/empty
- Example:
```hetu
// CORRECT - Named parameters
fun Screen({id, title, children}) {
  final result = {
    widgetType: 'Screen',
    id: id,
    title: title,
    children: children ?? [],
  }
  return result
}

// INCORRECT - Positional parameters won't match named calls
fun Screen(id, title, children) { ... }  // WRONG
```

### Object Merging in Hetu Scripts
- Use **spread syntax** `{...obj1, ...obj2}` to merge objects, NOT `Object.assign()`
- `Object.assign()` is not available in Hetu runtime context
- Example:
```hetu
// CORRECT - Spread syntax
final rules = {
  ...validationRules,
  ...businessRules,
}

// INCORRECT - Object.assign doesn't exist
final rules = Object.assign({}, validationRules, businessRules)  // WRONG
```

## Architecture Patterns

### Vlinder Runtime
- Use `VlinderRuntime` to load and parse UI files
- Runtime automatically initializes Hetu interpreter
- Example:
```dart
final runtime = VlinderRuntime();
final widget = runtime.loadUI(scriptContent, context);
```

### Widget Registry
- All widgets must be registered in `WidgetRegistry`
- Use `WidgetRegistry.htValueToDart()` to convert Hetu values to Dart types
- Example:
```dart
final dartValue = WidgetRegistry.htValueToDart(hetuValue);
```

### Parsers
- Parsers (UIParser, SchemaLoader, WorkflowParser, RulesParser) expect Hetu interpreter to be initialized
- They use `interpreter.fetch()` to get variables after `eval()`
- They iterate HTStruct using `for (final key in struct.keys)`
- **CRITICAL**: Always check if constructor functions exist before defining them to prevent "already defined" errors
- Example:
```dart
void _initializeConstructors() {
  try {
    interpreter.fetch('defineSchema'); // or 'Screen', 'defineRule', etc.
    // Function already exists, skip definition
    return;
  } catch (_) {
    // Function doesn't exist, proceed with definition
  }
  interpreter.eval(constructorScript);
}
```
- Do NOT prepend constructor scripts in `load*()` methods - they're already defined in constructor

### Action Handler
- Use `ActionHandler` for executing Hetu script actions
- Actions are invoked using `interpreter.invoke()`
- ActionHandler tries Hetu functions first, then falls back to string-based actions
- Example:
```dart
final handler = ActionHandler(interpreter: hetu);
await handler.executeAction('actionName', params: {...});
```

### Action Functions (actions.ht)
- **REQUIRED**: `actions.ht` file must exist and be loaded for app initialization
- Action functions are Hetu script functions defined in `actions.ht`
- **CRITICAL**: Action functions must be defined with **NO parameters**
- ActionHandler injects `actionContext` automatically with form values and validation state
- Example:
```hetu
// CORRECT - No parameters, access actionContext
fun submit_customer() {
  final formValues = actionContext.formValues ?? {}
  final isValid = actionContext.isValid ?? false
  // ... use formValues and isValid
}

// INCORRECT - Don't define parameters
fun submit_customer(params) { ... }  // WRONG
```

### Database Functions in Hetu Scripts
- Database functions (`save()`, `query()`, `executeSQL()`, etc.) are **automatically registered** in the Hetu interpreter
- They are available in all `.ht` files (actions.ht, workflows.ht, rules.ht, etc.)
- **CRITICAL**: Database operations use an **async queue pattern**
  - Functions queue operations and return operation IDs immediately
  - Operations are processed by ActionHandler **after** the action function completes
  - Results are available via `getDbResult(opId)` in subsequent actions or function calls
- Example:
```hetu
fun submit_customer() {
  // Queue operation - returns immediately
  final saveOpId = save('Customer', actionContext.formValues)
  
  // Operation is processed AFTER this function completes
  // Cannot get results synchronously within the same function
}
```
- All database functions use the **same interpreter instance** (shared via HetuInterpreterProvider)
- Functions are registered in `ContainerAppShell._registerDatabaseFunctions()`

### Database Operation Processing
- **CRITICAL**: Operations queued from Hetu scripts are `HTStruct`, not `Map`
- When processing operations in `ActionHandler._processDatabaseOperations()`, check for both `Map` and `HTStruct`:
```dart
if (operation is Map || operation is HTStruct) {
  final opId = operation['id'];
  final opType = operation['type']?.toString() ?? '';
  // ... process operation
}
```
- **CRITICAL**: Convert HTStruct operation data to Dart types before passing to database API:
```dart
final data = operation['data'];
if (data != null) {
  final dartData = _convertHetuValueToDart(data); // Converts HTStruct to Map
  result = await databaseAPI!.save(entityName, dartData);
}
```
- **CRITICAL**: Use explicit column names from schema in SQL queries, NOT `SELECT *`
  - `SELECT *` causes generic column names (`column0`, `column1`, etc.) instead of field names
  - Build column list from schema: `final columnNames = schema.fields.keys.toList();`
  - Use: `SELECT ${columnNames.join(', ')} FROM $tableName`
- **CRITICAL**: `findAll()` returns a `List`, not a single item
  - When retrieving results via `getDbResult()`, check if result is a List and extract first item:
```dart
dynamic customerData = queryResult;
if (queryResult is List && queryResult.isNotEmpty) {
  customerData = queryResult[0];
}
```
- **CRITICAL**: Store database results with string keys in `_dbResults` HTStruct
  - Convert numeric operation IDs to strings: `"${entry.key}"` when building Hetu script
  - Access results with string keys: `getDbResult(opId.toString())`

### Interpreter Instance Sharing
- **CRITICAL**: Share a single Hetu interpreter instance across all components
- This ensures UI scripts can access schemas, workflows, and rules loaded by parsers
- Pattern:
  1. Create interpreter in `ContainerAppShell` first
  2. Pass it to `VlinderRuntime(interpreter: sharedInterpreter)`
  3. Wrap loaded UI with `HetuInterpreterProvider` so widgets can access it
  4. Widgets use `HetuInterpreterProvider.of(context)` to get the interpreter
- Example:
```dart
// In ContainerAppShell
_interpreter = Hetu();
_interpreter.init();
_runtime = VlinderRuntime(interpreter: _interpreter);

// Wrap UI with provider
return HetuInterpreterProvider(
  interpreter: _interpreter,
  child: _loadedUI!,
);

// In widgets
final interpreter = HetuInterpreterProvider.of(context);
```
- Benefits:
  - Single source of truth for all Hetu state
  - UI scripts can reference schemas/workflows/rules
  - Action handlers have access to all loaded data
  - Database functions are available in all `.ht` files
  - Prevents state isolation issues

## File Organization

- `lib/vlinder/runtime/` - Runtime engine and action handlers
- `lib/vlinder/parser/` - Parsers for .ht files
- `lib/vlinder/core/` - Core utilities (WidgetRegistry)
- `lib/vlinder/widgets/` - Vlinder SDK widgets
- `lib/vlinder/schema/` - Schema loading and parsing
- `lib/vlinder/workflow/` - Workflow engine and parsing
- `lib/vlinder/rules/` - Rules engine and parsing

## Testing & Validation

### Test Scripts
- Use `scripts/test_and_validate.sh` to run all tests and validations
- Tests include Hetu script runtime validation using actual parsers
- Validation checks cross-file references and structure

### Test Files
- `test/hetu_validator.dart` - Validates individual .ht file types
- `test/integration_test.dart` - End-to-end app startup simulation
- Tests use actual Vlinder parsers to ensure compatibility

### Validation Patterns
- Load .ht files from `sample_app/assets/` directory
- Use actual parsers (SchemaLoader, UIParser, etc.) for validation
- Check required fields, type consistency, and cross-file references
- Verify workflow step references and rule condition syntax

## Drift Database Usage

### Custom SQL Execution
- **DO NOT** use `NativeDatabase.executor` or `LazyDatabase.connection` directly - these don't exist
- Use `sqlite3` package directly for custom SQL execution:
```dart
import 'package:sqlite3/sqlite3.dart';

Future<void> customStatement(String sql) async {
  final db = sqlite3.open(dbFile.path);
  db.execute(sql);
  db.dispose();
}
```
- Add `sqlite3: ^2.4.0` to `pubspec.yaml` dependencies
- Cache the sqlite3 Database instance if executing multiple statements

### Database Connection
- `NativeDatabase` doesn't expose `connection` getter directly
- For Drift operations, use `LazyDatabase` wrapper properly
- For custom SQL, use sqlite3 directly

## Debug Logging

### Debug Output Patterns
- Use `debugPrint()` with component prefixes for better log filtering
- Prefix format: `[ComponentName] Message`
- Examples:
```dart
debugPrint('[VlinderDatabase] Creating table from schema: ${schema.name}');
debugPrint('[ContainerAppShell] Starting app initialization');
debugPrint('[UIParser] Parsing UI script (${scriptContent.length} characters)');
debugPrint('[SchemaLoader] Loaded ${schemas.length} schemas');
```
- Include error context: `debugPrint('[Component] Error: $e'); debugPrint('[Component] Stack trace: $stackTrace');`

## Import Paths

### When to Use Relative vs Package Imports
- Use **relative imports** (`../vlinder/vlinder.dart`) when package isn't properly configured
- Use **package imports** (`package:vlinder/vlinder.dart`) when package is properly set up
- If you get "Target of URI doesn't exist" errors, switch to relative imports

## Material Icons

### Missing Icons
- `Icons.asterisk` does NOT exist in Material Icons
- Use Text widget with "*" character instead:
```dart
// WRONG
Icon(Icons.asterisk, size: 12, color: Colors.red)

// CORRECT
Padding(
  padding: EdgeInsets.all(8.0),
  child: Text('*', style: TextStyle(color: Colors.red, fontSize: 16)),
)
```

## Flutter Widget Patterns

### InheritedWidget Access
- **CRITICAL**: Never access InheritedWidgets (like `FormStateProvider`, `HetuInterpreterProvider`) in `initState()`
- Access InheritedWidgets in `build()` or `didChangeDependencies()` only
- `didChangeDependencies()` is called after `initState()` and whenever dependencies change
- Example:
```dart
// CORRECT - Access in didChangeDependencies()
class _VlinderTextFieldState extends State<VlinderTextField> {
  FormStateManager? _formState;
  bool _listenerAdded = false;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController();
    // DO NOT access FormStateProvider here
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final formState = FormStateProvider.of(context); // OK here
    if (formState != null && !_listenerAdded) {
      _formState = formState;
      // Set up listeners, load initial values, etc.
      _listenerAdded = true;
    }
  }

  @override
  Widget build(BuildContext context) {
    final formState = FormStateProvider.of(context); // Also OK here
    // Use formState in build
  }
}

// INCORRECT - Accessing in initState() causes runtime error
@override
void initState() {
  super.initState();
  final formState = FormStateProvider.of(context); // WRONG - causes error
}
```

### Form Widgets
- Form widgets use `fields` array for child widgets, not `children`
- The parser automatically handles this - `fields` become children
- Empty `children` arrays on Form widgets are automatically skipped
- **CRITICAL**: Form widgets must wrap **themselves** with `FormStateProvider`, not just their children
  - This makes form state available to sibling widgets (like ActionButton)
  - Wrap the form content in `build()` method:
```dart
@override
Widget build(BuildContext context) {
  final formStateToUse = widget.formState ?? _formState;
  if (formStateToUse != null) {
    return FormStateProvider(
      formState: formStateToUse,
      child: formContent, // Wrap form content, not just children
    );
  }
  return formContent;
}
```
- **CRITICAL**: Avoid `setState()` during build phase
  - Use `WidgetsBinding.instance.addPostFrameCallback()` to defer setState calls:
```dart
onFormStateReady: (formState) {
  // Defer setState to avoid calling during build
  WidgetsBinding.instance.addPostFrameCallback((_) {
    if (mounted && _screenFormState != formState) {
      setState(() {
        _screenFormState = formState;
      });
    }
  });
}
```

## Best Practices

1. **Always initialize Hetu** - Call `init()` immediately after creating Hetu instance
2. **Use fetch, not getType** - The method is `fetch()`, not `getType()`
3. **Use invoke, not call** - The method is `invoke()`, not `call()`
4. **Check for HTStruct** - Import values.dart and check `value is HTStruct` before accessing
5. **Iterate with keys** - Use `for (final key in struct.keys)` not `forEach()`
6. **Type check with Dart types** - Use `String`, `int`, `bool`, etc., not HT* wrapper types
7. **Handle errors gracefully** - Wrap Hetu operations in try-catch blocks
8. **Validate before deploy** - Run `test_and_validate.sh` before deploying .ht files
9. **Test runtime behavior** - Use actual parsers in tests, not just syntax checking
10. **Prevent function redefinition** - Always check if Hetu functions exist before defining them
11. **Use debug logging** - Add comprehensive debug output with component prefixes
12. **Use sqlite3 for custom SQL** - Don't try to access executor through NativeDatabase
13. **Share interpreter instance** - Use single interpreter across ContainerAppShell, VlinderRuntime, and widgets via HetuInterpreterProvider
14. **Access interpreter from context** - Widgets should use `HetuInterpreterProvider.of(context)` instead of creating new instances
15. **Use named parameters in Hetu constructors** - Widget constructor functions must use `{param1, param2}` syntax
16. **Use spread syntax for object merging** - Use `{...obj1, ...obj2}` not `Object.assign()`
17. **Access InheritedWidgets correctly** - Use `didChangeDependencies()` or `build()`, never `initState()`
18. **Define action functions with NO parameters** - ActionHandler injects `actionContext` automatically
19. **Database functions are automatically available** - No import needed, they're registered in ContainerAppShell
20. **Database operations are async** - Functions queue operations, results available via `getDbResult(opId)` after processing
21. **actions.ht is required** - Must exist and be loaded for app initialization
22. **Use actionContext in action functions** - Access form values via `actionContext.formValues` and validation via `actionContext.isValid`
23. **Handle HTStruct in database operations** - Operations from Hetu are HTStruct, check for both Map and HTStruct when processing
24. **Convert HTStruct to Dart types** - Always use `_convertHetuValueToDart()` before passing to database API
25. **Use explicit column names** - Build column list from schema fields, don't use `SELECT *` (causes generic column names)
26. **Handle List results from findAll** - `findAll()` returns List, extract first item if needed: `if (result is List && result.isNotEmpty) { result = result[0]; }`
27. **Use string keys for HTStruct** - Convert numeric keys to strings when storing: `"${key}"`, access with strings: `struct["1"]`
28. **Form widgets wrap themselves** - FormStateProvider should wrap the form content, not just children, to make state available to siblings
29. **Defer setState during build** - Use `WidgetsBinding.instance.addPostFrameCallback()` to avoid setState() during build errors

