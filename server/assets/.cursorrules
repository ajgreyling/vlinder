# Vlinder Hetu Script (.ht) File Rules

## File Types

Vlinder uses two types of .ht files and three YAML files:
- `schema.yaml` - Entity schema definitions (OpenAPI format)
- `ui.yaml` - UI widget tree definitions (YAML format)
- `workflows.yaml` - Workflow and step definitions (YAML format)
- `rules.ht` - Business rules and validation rules

## Schema Files (schema.yaml)

Schemas are defined in **OpenAPI YAML format** with JSON Schema component definitions. **Relationships between entities are defined using `$ref` references**, allowing entities to reference each other. Foreign key relationships are specified using the `x-foreign-key` extension for database-level constraints.

### Structure
- Use **OpenAPI YAML format** (OpenAPI 3.0 specification)
- Define schemas in `components/schemas` section
- Use JSON Schema for field definitions
- **Use `$ref: '#/components/schemas/EntityName'` references for relationships** - this is the primary way to define entity relationships
- Use `x-foreign-key: EntityName.field` extension for database foreign keys

### Field Types (JSON Schema)
- `string` - String/text field
- `integer` - Integer number field (use `format: int64` for large integers)
- `number` - Decimal/float number field (use `format: decimal` for precision)
- `string` with `format: date-time` - Date/time field
- `boolean` - Boolean field
- `array` - Array field (use `items` to specify item type)

### Example:
```yaml
openapi: 3.0.0
info:
  title: Vlinder Schema Definitions
  version: 1.0.0

components:
  schemas:
    Customer:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
          maxLength: 100
        email:
          type: string
          format: email
          pattern: '^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$'
        age:
          type: integer
          minimum: 0
          maximum: 150
        phone:
          type: string
          maxLength: 20
        createdAt:
          type: string
          format: date-time
        orders:
          type: array
          items:
            $ref: '#/components/schemas/Order'
      required:
        - id
        - name
        - email
        - createdAt
    
    Order:
      type: object
      properties:
        id:
          type: integer
          format: int64
        customerId:
          type: integer
          format: int64
          x-foreign-key: Customer.id
        customer:
          $ref: '#/components/schemas/Customer'
        total:
          type: number
          format: decimal
          minimum: 0
        createdAt:
          type: string
          format: date-time
      required:
        - id
        - customerId
        - total
```

### Constraints (JSON Schema)
- `maxLength` - Maximum string length
- `minimum`, `maximum` - Numeric range
- `pattern` - Regex pattern for validation
- `format` - Data format (email, date-time, decimal, int64, etc.)

### Relationships Using References
- **One-to-Many**: Use `type: array` with `items: $ref: '#/components/schemas/EntityName'` to reference another schema
- **Many-to-One**: Use `$ref: '#/components/schemas/EntityName'` directly in a property to reference another schema
- **Foreign Keys**: Use `x-foreign-key: EntityName.field` extension for database relationships (works alongside `$ref` references)
- **Many-to-Many**: Use a junction table schema with `$ref` references and foreign keys to both entities

### Key Features
- **Industry Standard**: Uses OpenAPI 3.0 and JSON Schema specifications
- **Dual Database Support**: Works for both PostgreSQL and SQLite/Drift
- **Relationship Support**: `$ref` references enable complex entity relationships
- **Foreign Key Mapping**: `x-foreign-key` extension maps to database foreign keys

## UI Files (ui.yaml)

### Structure
- Must define a `screen` key at the root level
- Screen contains `children` array with widgets
- Forms use `widgetType: Form` with `entity` and `fields` array
- All widgets must have a `widgetType` property

### Available Widgets
- `Screen` - Root screen container
- `Form` - Form container with entity binding
- `TextField` - Text input field
- `NumberField` - Numeric input field (integer or decimal)
- `BooleanField` - Boolean input field (Yes/No dropdown)
- `SingleSelectField` - Single-choice dropdown selection
- `ActionButton` - Action button
- `Text` - Text display widget

### Example:
```yaml
patientHealthInfo:
  widgetType: Screen
  id: patient_health_info
  title: Health Information
  children:
    - widgetType: Form
      entity: Patient
      fields:
        - widgetType: TextField
          field: firstName
          label: First Name
          required: true
          placeholder: Enter first name
        - widgetType: NumberField
          field: age
          label: Age
          type: integer
          required: true
          placeholder: Enter age
        - widgetType: SingleSelectField
          field: gender
          label: Gender
          required: true
          placeholder: Select gender
          options:
            - Male
            - Female
            - Other
        - widgetType: BooleanField
          field: pregnant
          label: Pregnant?
          required: true
          visible: "age > 16 && gender == 'Female'"
    - widgetType: ActionButton
      label: Next
      action: next_to_senior_screening
      style: primary
```

### Widget Properties
- `widgetType` - Widget type identifier (required for all widgets)
- `id` - Unique identifier (required for Screen)
- `title` - Display title (Screen)
- `entity` - Entity name for form binding (Form)
- `field` - Field name from schema (TextField, NumberField, BooleanField, SingleSelectField)
- `label` - Display label
- `required` - Boolean for required fields
- `placeholder` - Placeholder text
- `type` - Field type: `integer` or `decimal` (NumberField)
- `options` - List of options for dropdown (SingleSelectField). Can be:
  - List of strings: `['Male', 'Female', 'Other']` (value = label)
  - List of maps: `[{value: 'M', label: 'Male'}, ...]` (explicit value/label)
- `visible` - Hetu expression for conditional visibility (TextField, NumberField, BooleanField, SingleSelectField)
- `readOnly` - Boolean for read-only fields
- `action` - Action identifier (ActionButton)
- `style` - Button style: `primary` or `secondary` (ActionButton)
- `text` - Text content (Text widget)

### Conditional Field Visibility

Fields can be conditionally shown or hidden using the `visible` property with Hetu script expressions:

```yaml
- widgetType: BooleanField
  field: pregnant
  label: Pregnant?
  required: true
  visible: "age > 16 && gender == 'Female'"
```

**Key Points:**
- `visible` property accepts a Hetu script expression string
- Expression is evaluated against current form values
- Expression must evaluate to a boolean (`true` = visible, `false` = hidden)
- Fields are hidden by returning `SizedBox.shrink()` when not visible
- Visibility updates reactively as form values change using `ValueListenableBuilder`
- Form values are injected as variables into the Hetu interpreter for evaluation
- Example expressions:
  - `"age > 16 && gender == 'Female'"` - Show for females over 16
  - `"age > 50 && gender == 'Male'"` - Show for males over 50
  - `"age != null"` - Show when age is set

## Workflow Files (workflows.yaml)

### Structure
- Define workflows in YAML format under a `workflows` key
- Each workflow has: `id`, `label`, `initialStep`, `steps`
- Workflows are defined as a map with workflow IDs as keys

### Step Structure
- Each step has: `id`, `label`, `screenId`, `nextSteps`, `conditions`
- `nextSteps` is a list of step IDs
- `conditions` is a map (can be empty: `{}`)
- Empty `nextSteps` list indicates final step

### Example:
```yaml
workflows:
  patient_registration:
    id: patient_registration
    label: Patient Registration
    initialStep: landing
    steps:
      health_info:
        id: health_info
        label: Health Information
        screenId: patient_health_info
        nextSteps:
          - senior_screening
          - complete
        conditions:
          senior_screening: "age > 50"
          complete: "age <= 50"
      senior_screening:
        id: senior_screening
        label: Senior Health Screening
        screenId: patient_senior_screening
        nextSteps:
          - complete
        conditions: {}
```

**Conditional Transitions:**
- Use `conditions` map to define when steps should be shown
- Conditions are Hetu expressions evaluated against form values
- Multiple `nextSteps` with conditions allow branching logic

## Rules Files (rules.ht)

### Structure
- Define rules as struct literals grouped in maps
- Use descriptive variable names (e.g., `validationRules`, `businessRules`)
- Each rule has: `id`, `name`, `condition`, `action`, `params`

### Condition Syntax
- Hetu script expressions that evaluate to boolean
- Access context via `context.field`, `context.value`, etc.
- Example conditions:
  - `context.field == "email" && context.value == null`
  - `context.value < 0 || context.value > 150`
  - `context.totalAmount > 1000`

### Action Syntax
- Hetu script expressions or function calls
- Examples:
  - `showError("Email is required")`
  - `formatPhoneNumber(context.value)`
  - `applyDiscount(0.1)`

### Example:
```hetu
final validationRules = {
  firstName_required: {
    ruleType: 'Rule',
    id: 'firstName_required',
    name: 'First Name Required',
    condition: 'context.field == "firstName" && (context.value == null || context.value.toString().isEmpty)',
    action: 'showError("First name is required")',
  },
  pregnant_required_female_over_16: {
    ruleType: 'Rule',
    id: 'pregnant_required_female_over_16',
    name: 'Pregnant Required for Females Over 16',
    condition: 'context.field == "pregnant" && context.formValues["age"] != null && context.formValues["age"] > 16 && context.formValues["gender"] == "Female" && context.value == null',
    action: 'showError("Pregnant status is required for females over 16")',
  },
};
```

**Conditional Validation:**
- Rules can access other form values via `context.formValues["fieldName"]`
- Use conditional logic to apply rules based on multiple field values
- Combine with `visible` property in UI for consistent conditional behavior

## Hetu Script Syntax

### Variables
- Use `final` for immutable variables
- Variable names should be camelCase
- Example: `final customerSchema = {...}`

### Structs
- Use `{key: value}` syntax for struct literals
- Nested structs are supported
- Access with dot notation: `struct.key`

### Arrays
- Use `[item1, item2]` syntax
- Can contain structs, primitives, or mixed types

### Functions
- Widget constructors are functions: `Screen(...)`, `Form(...)`
- Use named parameters: `TextField(field: 'name', label: 'Name')`
- Optional parameters can be omitted

### Comments
- Use `//` for single-line comments
- Comments are ignored by parser

## Best Practices

1. **Consistent Naming**
   - Schemas: `*Schema` suffix
   - Workflows: `*Workflow` suffix
   - Rules: Group in descriptive maps

2. **Required Fields**
   - Screen: `id` is required
   - Schema: `name`, `primaryKey`, `fields` are required
   - Workflow: `id`, `initialStep`, `steps` are required
   - Rule: `id` is required

3. **Entity References**
   - Form `entity` must match a schema `name`
   - Field names in widgets must match schema field names
   - Screen IDs in workflows must match Screen `id` values

4. **Type Consistency**
   - Field types in widgets must match schema field types
   - NumberField `type` must be 'integer' or 'decimal'

5. **Workflow Structure**
   - `initialStep` must exist in `steps`
   - All `nextSteps` IDs must exist in `steps`
   - At least one step should have empty `nextSteps` (final step)

6. **Rule Conditions**
   - Must evaluate to boolean
   - Use `context` object to access form state
   - Keep conditions simple and readable

7. **Error Handling**
   - Use descriptive error messages in rule actions
   - Validate required fields in schemas
   - Ensure all references are valid

## Testing & Validation

### Validation Script
Run `./scripts/test_and_validate.sh` to validate all .ht files:
- Syntax validation (can parse without errors)
- Structure validation (required fields, correct types)
- Runtime validation (actually loads and parses like the app would)
- Cross-file reference validation

### Validation Checks
- Schema files: Required fields (`name`, `primaryKey`, `fields`), valid field types
- UI files: `screen` key exists in YAML, Form `entity` matches Schema names, valid YAML syntax
- Workflow files: `initialStep` exists, all `nextSteps` references valid
- Rules files: Condition syntax can be evaluated, action syntax valid

### Common Issues
- Missing required fields in schemas or workflows
- Form `entity` references non-existent schema
- Workflow `screenId` doesn't match Screen `id`
- Field names in widgets don't match schema field names
- Rule conditions have syntax errors
- Invalid YAML syntax in `ui.yaml` (indentation, missing colons, etc.)
- Missing `widgetType` property on widgets
- Conditional visibility expressions not evaluating correctly (check form values are set)
- BooleanField not showing/hiding when expected (verify `visible` expression syntax)
- Conditional required fields not validating (ensure rules match visibility conditions)

## Actions Files (actions.ht)

### Structure
- Define action functions using `fun` keyword
- Actions have NO parameters - `actionContext` is injected automatically
- Access form values via `actionContext.formValues`
- Access validation state via `actionContext.isValid`

### Example:
```hetu
fun submit_patient() {
  final formValues = actionContext.formValues ?? {}
  final isValid = actionContext.isValid ?? false
  
  if (!isValid) {
    logError("Form validation failed")
    return
  }
  
  // Save to database
  final saveOpId = save('Patient', formValues)
}
```

### Navigation Actions
- Use `navigate_` prefix for string-based navigation
- Or implement custom navigation logic in action functions
- Validate form state before navigation
- Use conditional logic to skip steps based on form values

### Key Points
- Actions are Hetu script functions with NO parameters
- `actionContext` is automatically injected by ActionHandler
- Database operations are queued and processed after action completes
- Use `getDbResult(opId)` to retrieve database operation results

